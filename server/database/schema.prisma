generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model migrations {
  id          Int       @id
  name        String    @unique @db.VarChar(100)
  hash        String    @db.VarChar(40)
  executed_at DateTime? @default(now()) @db.Timestamp(6)
}

model TosApproval {
  id          Int                    @id @default(autoincrement())
  address     String                 @db.VarChar(66)
  doc_version String                 @db.VarChar
  sign_date   DateTime               @db.Timestamp(6)
  signature   String                 @default("0x0") @db.VarChar
  message     String                 @default("0x0") @db.VarChar
  chain_id    Int                    @default(0)
  vaults      UsersWhoFollowVaults[]

  @@unique([address, chain_id, doc_version])
  @@unique([address, doc_version], name: "tos_approval_unique_signature", map: "tos_approval_unique_signature")
  @@map("tos_approval")
}

/// The underlying table does not contain a valid unique identifier and can therefore currently not be handled by the Prisma Client.
model Vault {
  vault_id      Int
  type          VaultType
  owner_address String                 @db.Char(42)
  chain_id      Int?
  users         UsersWhoFollowVaults[]

  @@unique([vault_id, chain_id], name: "vault_vault_id_chain_id_unique_constraint", map: "vault_vault_id_chain_id_unique_constraint")
  @@map("vault")
  @@ignore
}

model User {
  address                    String        @unique
  timestamp                  DateTime      @default(now())
  user_that_referred_address String?
  accepted                   Boolean
  user_that_referred         User?         @relation("UserToUser", fields: [user_that_referred_address], references: [address])
  referred_users             User[]        @relation("UserToUser")
  weekly_claims              WeeklyClaim[]

  @@map("user")
}

model WeeklyClaim {
  id           Int       @id @default(autoincrement())
  week_number  Int
  user_address String
  proof        String[]
  amount       String
  timestamp    DateTime? @default(now())
  claimant     User      @relation(fields: [user_address], references: [address])

  @@unique([week_number, user_address], name: "week_number_userAddress_unique_id")
  @@map("weekly_claim")
}

model MerkleTree {
  week_number Int       @unique
  tree_root   String
  start_block Decimal?  @db.Decimal(78, 0)
  end_block   Decimal?  @db.Decimal(78, 0)
  timestamp   DateTime? @default(now())
  snapshot    String?

  @@map("merkle_tree")
}

model WalletRisk {
  address    String   @unique(map: "wallet_risk_unique_index") @db.VarChar(66)
  last_check DateTime @db.Timestamp(6)
  is_risky   Boolean

  @@map("wallet_risk")
}

model CollateralType {
  collateral_name     String   @id(map: "collateral_name_key")
  next_price          Decimal
  current_price       Decimal
  liquidation_ratio   Decimal
  liquidation_penalty Decimal? @default(1.13)
  rate                Decimal?
  market_price        Decimal?

  @@map("collateral_type")
}

model Discover {
  protocol_id           String
  position_id           String
  collateral_type       String
  vault_normalized_debt Decimal?
  vault_debt            Decimal
  vault_collateral      Decimal
  yield_30d             Decimal
  status                Json
  last_action           Json
  pnl_all               Decimal
  pnl_1d                Decimal
  pnl_7d                Decimal
  pnl_30d               Decimal
  pnl_365d              Decimal
  pnl_ytd               Decimal
  createdAt             DateTime @default(now())
  updatedAt             DateTime
  token                 String?
  vault_type            String?
  net_profit_all        Decimal?
  net_profit_1d         Decimal?
  net_profit_7d         Decimal?
  net_profit_30d        Decimal?
  net_profit_365d       Decimal?
  net_profit_ytd        Decimal?

  @@unique([protocol_id, position_id])
  @@map("discover")
}

model UsersWhoFollowVaults {
  user_address    String
  vault_id        Int
  tos_doc_version String
  vault_chain_id  Int
  user            TosApproval @relation(fields: [user_address, vault_chain_id, tos_doc_version], references: [address, chain_id, doc_version])
  vault           Vault       @relation(fields: [vault_id, vault_chain_id], references: [vault_id, chain_id]) @ignore

  @@id([user_address, vault_id, vault_chain_id])
  @@map("users_who_follow_vaults")
}

enum VaultType {
  borrow
  multiply

  @@map("vault_type")
}
