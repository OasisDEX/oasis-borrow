# This file was generated. Do not edit manually.

schema {
  query: Query
  subscription: Subscription
}

"creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API."
directive @derivedFrom(field: String!) on FIELD_DEFINITION

"Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive."
directive @entity on OBJECT

"Defined a Subgraph ID for an object type"
directive @subgraphId(id: String!) on OBJECT

type CDP {
  collateralToken: Token!
  id: ID!
  ilk: Bytes!
  ilkName: String!
  owner: Bytes!
  triggers(first: Int = 100, orderBy: Trigger_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Trigger_filter): [Trigger!]!
  urn: Urn!
}

type Liquidation {
  blockNumber: BigInt!
  cdp: CDP!
  id: ID!
  logIndex: BigInt!
  transactionHash: Bytes!
  triggers(first: Int = 100, orderBy: TriggerLiquidation_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: TriggerLiquidation_filter): [TriggerLiquidation!]!
}

type Query {
  "Access to subgraph metadata"
  _meta(block: Block_height): _Meta_
  cdp(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CDP
  cdps(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: CDP_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: CDP_filter
  ): [CDP!]!
  liquidation(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Liquidation
  liquidations(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: Liquidation_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: Liquidation_filter
  ): [Liquidation!]!
  token(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Token
  tokens(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: Token_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: Token_filter
  ): [Token!]!
  trigger(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Trigger
  triggerEvent(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TriggerEvent
  triggerEvents(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: TriggerEvent_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: TriggerEvent_filter
  ): [TriggerEvent!]!
  triggerLiquidation(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TriggerLiquidation
  triggerLiquidations(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: TriggerLiquidation_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: TriggerLiquidation_filter
  ): [TriggerLiquidation!]!
  triggers(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: Trigger_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: Trigger_filter
  ): [Trigger!]!
  urn(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Urn
  urns(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: Urn_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: Urn_filter
  ): [Urn!]!
}

type Subscription {
  "Access to subgraph metadata"
  _meta(block: Block_height): _Meta_
  cdp(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CDP
  cdps(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: CDP_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: CDP_filter
  ): [CDP!]!
  liquidation(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Liquidation
  liquidations(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: Liquidation_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: Liquidation_filter
  ): [Liquidation!]!
  token(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Token
  tokens(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: Token_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: Token_filter
  ): [Token!]!
  trigger(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Trigger
  triggerEvent(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TriggerEvent
  triggerEvents(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: TriggerEvent_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: TriggerEvent_filter
  ): [TriggerEvent!]!
  triggerLiquidation(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TriggerLiquidation
  triggerLiquidations(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: TriggerLiquidation_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: TriggerLiquidation_filter
  ): [TriggerLiquidation!]!
  triggers(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: Trigger_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: Trigger_filter
  ): [Trigger!]!
  urn(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    id: ID!,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Urn
  urns(
    "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
    block: Block_height,
    first: Int = 100,
    orderBy: Urn_orderBy,
    orderDirection: OrderDirection,
    skip: Int = 0,
    "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
    subgraphError: _SubgraphErrorPolicy_! = deny,
    where: Urn_filter
  ): [Urn!]!
}

type Token {
  address: Bytes!
  decimals: BigInt!
  id: Bytes!
  precision: BigInt!
  symbol: String!
  triggers(first: Int = 100, orderBy: Trigger_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Trigger_filter): [Trigger!]!
}

type Trigger {
  account: Bytes
  addedBlock: BigInt!
  addedLogIndex: BigInt!
  addedTimestamp: BigInt!
  addedTransaction: Bytes!
  cdp: CDP
  cdpId: BigInt
  commandAddress: Bytes!
  continuous: Boolean!
  decodedData: [String!]!
  decodedDataNames: [String!]!
  executedBlock: BigInt
  executedLogIndex: BigInt
  executedTimestamp: BigInt
  executedTransaction: Bytes
  id: ID!
  kind: String!
  liquidations(first: Int = 100, orderBy: TriggerLiquidation_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: TriggerLiquidation_filter): [TriggerLiquidation!]!
  owner: Bytes
  protocol: String
  removedBlock: BigInt
  removedLogIndex: BigInt
  removedTimestamp: BigInt
  removedTransaction: Bytes
  tokens(first: Int = 100, orderBy: Token_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Token_filter): [Token!]!
  triggerData: Bytes!
  triggerType: BigInt!
  version: BigInt!
}

type TriggerEvent {
  account: Bytes
  block: BigInt!
  eventType: String!
  id: Bytes!
  logIndex: BigInt!
  owner: Bytes
  timestamp: BigInt!
  transaction: Bytes!
  trigger: Trigger!
}

type TriggerLiquidation {
  id: ID!
  liquidation: Liquidation!
  trigger: Trigger!
}

"Urn to CDP Lookup"
type Urn {
  cdp: CDP!
  id: ID!
}

type _Block_ {
  "The hash of the block"
  hash: Bytes
  "The block number"
  number: Int!
  "Integer representation of the timestamp stored in blocks for the chain"
  timestamp: Int
}

"The type for the top-level _meta field"
type _Meta_ {
  """

  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  """
  block: _Block_!
  "The deployment ID"
  deployment: String!
  "If `true`, the subgraph encountered indexing errors at some past block"
  hasIndexingErrors: Boolean!
}

enum CDP_orderBy {
  collateralToken
  collateralToken__address
  collateralToken__decimals
  collateralToken__id
  collateralToken__precision
  collateralToken__symbol
  id
  ilk
  ilkName
  owner
  triggers
  urn
  urn__id
}

enum Liquidation_orderBy {
  blockNumber
  cdp
  cdp__id
  cdp__ilk
  cdp__ilkName
  cdp__owner
  id
  logIndex
  transactionHash
  triggers
}

"Defines the order direction, either ascending or descending"
enum OrderDirection {
  asc
  desc
}

enum Token_orderBy {
  address
  decimals
  id
  precision
  symbol
  triggers
}

enum TriggerEvent_orderBy {
  account
  block
  eventType
  id
  logIndex
  owner
  timestamp
  transaction
  trigger
  trigger__account
  trigger__addedBlock
  trigger__addedLogIndex
  trigger__addedTimestamp
  trigger__addedTransaction
  trigger__cdpId
  trigger__commandAddress
  trigger__continuous
  trigger__executedBlock
  trigger__executedLogIndex
  trigger__executedTimestamp
  trigger__executedTransaction
  trigger__id
  trigger__kind
  trigger__owner
  trigger__protocol
  trigger__removedBlock
  trigger__removedLogIndex
  trigger__removedTimestamp
  trigger__removedTransaction
  trigger__triggerData
  trigger__triggerType
  trigger__version
}

enum TriggerLiquidation_orderBy {
  id
  liquidation
  liquidation__blockNumber
  liquidation__id
  liquidation__logIndex
  liquidation__transactionHash
  trigger
  trigger__account
  trigger__addedBlock
  trigger__addedLogIndex
  trigger__addedTimestamp
  trigger__addedTransaction
  trigger__cdpId
  trigger__commandAddress
  trigger__continuous
  trigger__executedBlock
  trigger__executedLogIndex
  trigger__executedTimestamp
  trigger__executedTransaction
  trigger__id
  trigger__kind
  trigger__owner
  trigger__protocol
  trigger__removedBlock
  trigger__removedLogIndex
  trigger__removedTimestamp
  trigger__removedTransaction
  trigger__triggerData
  trigger__triggerType
  trigger__version
}

enum Trigger_orderBy {
  account
  addedBlock
  addedLogIndex
  addedTimestamp
  addedTransaction
  cdp
  cdpId
  cdp__id
  cdp__ilk
  cdp__ilkName
  cdp__owner
  commandAddress
  continuous
  decodedData
  decodedDataNames
  executedBlock
  executedLogIndex
  executedTimestamp
  executedTransaction
  id
  kind
  liquidations
  owner
  protocol
  removedBlock
  removedLogIndex
  removedTimestamp
  removedTransaction
  tokens
  triggerData
  triggerType
  version
}

enum Urn_orderBy {
  cdp
  cdp__id
  cdp__ilk
  cdp__ilkName
  cdp__owner
  id
}

enum _SubgraphErrorPolicy_ {
  "Data will be returned even if the subgraph has indexing errors"
  allow
  "If the subgraph has indexing errors, data will be omitted. The default."
  deny
}

scalar BigDecimal

scalar BigInt

scalar Bytes

"""

8 bytes signed integer
"""
scalar Int8

input BlockChangedFilter {
  number_gte: Int!
}

input Block_height {
  hash: Bytes
  number: Int
  number_gte: Int
}

input CDP_filter {
  "Filter for the block changed event."
  _change_block: BlockChangedFilter
  and: [CDP_filter]
  collateralToken: String
  collateralToken_: Token_filter
  collateralToken_contains: String
  collateralToken_contains_nocase: String
  collateralToken_ends_with: String
  collateralToken_ends_with_nocase: String
  collateralToken_gt: String
  collateralToken_gte: String
  collateralToken_in: [String!]
  collateralToken_lt: String
  collateralToken_lte: String
  collateralToken_not: String
  collateralToken_not_contains: String
  collateralToken_not_contains_nocase: String
  collateralToken_not_ends_with: String
  collateralToken_not_ends_with_nocase: String
  collateralToken_not_in: [String!]
  collateralToken_not_starts_with: String
  collateralToken_not_starts_with_nocase: String
  collateralToken_starts_with: String
  collateralToken_starts_with_nocase: String
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  ilk: Bytes
  ilkName: String
  ilkName_contains: String
  ilkName_contains_nocase: String
  ilkName_ends_with: String
  ilkName_ends_with_nocase: String
  ilkName_gt: String
  ilkName_gte: String
  ilkName_in: [String!]
  ilkName_lt: String
  ilkName_lte: String
  ilkName_not: String
  ilkName_not_contains: String
  ilkName_not_contains_nocase: String
  ilkName_not_ends_with: String
  ilkName_not_ends_with_nocase: String
  ilkName_not_in: [String!]
  ilkName_not_starts_with: String
  ilkName_not_starts_with_nocase: String
  ilkName_starts_with: String
  ilkName_starts_with_nocase: String
  ilk_contains: Bytes
  ilk_gt: Bytes
  ilk_gte: Bytes
  ilk_in: [Bytes!]
  ilk_lt: Bytes
  ilk_lte: Bytes
  ilk_not: Bytes
  ilk_not_contains: Bytes
  ilk_not_in: [Bytes!]
  or: [CDP_filter]
  owner: Bytes
  owner_contains: Bytes
  owner_gt: Bytes
  owner_gte: Bytes
  owner_in: [Bytes!]
  owner_lt: Bytes
  owner_lte: Bytes
  owner_not: Bytes
  owner_not_contains: Bytes
  owner_not_in: [Bytes!]
  triggers: [String!]
  triggers_: Trigger_filter
  triggers_contains: [String!]
  triggers_contains_nocase: [String!]
  triggers_not: [String!]
  triggers_not_contains: [String!]
  triggers_not_contains_nocase: [String!]
  urn_: Urn_filter
}

input Liquidation_filter {
  "Filter for the block changed event."
  _change_block: BlockChangedFilter
  and: [Liquidation_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  cdp: String
  cdp_: CDP_filter
  cdp_contains: String
  cdp_contains_nocase: String
  cdp_ends_with: String
  cdp_ends_with_nocase: String
  cdp_gt: String
  cdp_gte: String
  cdp_in: [String!]
  cdp_lt: String
  cdp_lte: String
  cdp_not: String
  cdp_not_contains: String
  cdp_not_contains_nocase: String
  cdp_not_ends_with: String
  cdp_not_ends_with_nocase: String
  cdp_not_in: [String!]
  cdp_not_starts_with: String
  cdp_not_starts_with_nocase: String
  cdp_starts_with: String
  cdp_starts_with_nocase: String
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  logIndex: BigInt
  logIndex_gt: BigInt
  logIndex_gte: BigInt
  logIndex_in: [BigInt!]
  logIndex_lt: BigInt
  logIndex_lte: BigInt
  logIndex_not: BigInt
  logIndex_not_in: [BigInt!]
  or: [Liquidation_filter]
  transactionHash: Bytes
  transactionHash_contains: Bytes
  transactionHash_gt: Bytes
  transactionHash_gte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_lt: Bytes
  transactionHash_lte: Bytes
  transactionHash_not: Bytes
  transactionHash_not_contains: Bytes
  transactionHash_not_in: [Bytes!]
  triggers_: TriggerLiquidation_filter
}

input Token_filter {
  "Filter for the block changed event."
  _change_block: BlockChangedFilter
  address: Bytes
  address_contains: Bytes
  address_gt: Bytes
  address_gte: Bytes
  address_in: [Bytes!]
  address_lt: Bytes
  address_lte: Bytes
  address_not: Bytes
  address_not_contains: Bytes
  address_not_in: [Bytes!]
  and: [Token_filter]
  decimals: BigInt
  decimals_gt: BigInt
  decimals_gte: BigInt
  decimals_in: [BigInt!]
  decimals_lt: BigInt
  decimals_lte: BigInt
  decimals_not: BigInt
  decimals_not_in: [BigInt!]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  or: [Token_filter]
  precision: BigInt
  precision_gt: BigInt
  precision_gte: BigInt
  precision_in: [BigInt!]
  precision_lt: BigInt
  precision_lte: BigInt
  precision_not: BigInt
  precision_not_in: [BigInt!]
  symbol: String
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_gt: String
  symbol_gte: String
  symbol_in: [String!]
  symbol_lt: String
  symbol_lte: String
  symbol_not: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  symbol_not_in: [String!]
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
  triggers_: Trigger_filter
}

input TriggerEvent_filter {
  "Filter for the block changed event."
  _change_block: BlockChangedFilter
  account: Bytes
  account_contains: Bytes
  account_gt: Bytes
  account_gte: Bytes
  account_in: [Bytes!]
  account_lt: Bytes
  account_lte: Bytes
  account_not: Bytes
  account_not_contains: Bytes
  account_not_in: [Bytes!]
  and: [TriggerEvent_filter]
  block: BigInt
  block_gt: BigInt
  block_gte: BigInt
  block_in: [BigInt!]
  block_lt: BigInt
  block_lte: BigInt
  block_not: BigInt
  block_not_in: [BigInt!]
  eventType: String
  eventType_contains: String
  eventType_contains_nocase: String
  eventType_ends_with: String
  eventType_ends_with_nocase: String
  eventType_gt: String
  eventType_gte: String
  eventType_in: [String!]
  eventType_lt: String
  eventType_lte: String
  eventType_not: String
  eventType_not_contains: String
  eventType_not_contains_nocase: String
  eventType_not_ends_with: String
  eventType_not_ends_with_nocase: String
  eventType_not_in: [String!]
  eventType_not_starts_with: String
  eventType_not_starts_with_nocase: String
  eventType_starts_with: String
  eventType_starts_with_nocase: String
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  logIndex: BigInt
  logIndex_gt: BigInt
  logIndex_gte: BigInt
  logIndex_in: [BigInt!]
  logIndex_lt: BigInt
  logIndex_lte: BigInt
  logIndex_not: BigInt
  logIndex_not_in: [BigInt!]
  or: [TriggerEvent_filter]
  owner: Bytes
  owner_contains: Bytes
  owner_gt: Bytes
  owner_gte: Bytes
  owner_in: [Bytes!]
  owner_lt: Bytes
  owner_lte: Bytes
  owner_not: Bytes
  owner_not_contains: Bytes
  owner_not_in: [Bytes!]
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  transaction: Bytes
  transaction_contains: Bytes
  transaction_gt: Bytes
  transaction_gte: Bytes
  transaction_in: [Bytes!]
  transaction_lt: Bytes
  transaction_lte: Bytes
  transaction_not: Bytes
  transaction_not_contains: Bytes
  transaction_not_in: [Bytes!]
  trigger: String
  trigger_: Trigger_filter
  trigger_contains: String
  trigger_contains_nocase: String
  trigger_ends_with: String
  trigger_ends_with_nocase: String
  trigger_gt: String
  trigger_gte: String
  trigger_in: [String!]
  trigger_lt: String
  trigger_lte: String
  trigger_not: String
  trigger_not_contains: String
  trigger_not_contains_nocase: String
  trigger_not_ends_with: String
  trigger_not_ends_with_nocase: String
  trigger_not_in: [String!]
  trigger_not_starts_with: String
  trigger_not_starts_with_nocase: String
  trigger_starts_with: String
  trigger_starts_with_nocase: String
}

input TriggerLiquidation_filter {
  "Filter for the block changed event."
  _change_block: BlockChangedFilter
  and: [TriggerLiquidation_filter]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  liquidation: String
  liquidation_: Liquidation_filter
  liquidation_contains: String
  liquidation_contains_nocase: String
  liquidation_ends_with: String
  liquidation_ends_with_nocase: String
  liquidation_gt: String
  liquidation_gte: String
  liquidation_in: [String!]
  liquidation_lt: String
  liquidation_lte: String
  liquidation_not: String
  liquidation_not_contains: String
  liquidation_not_contains_nocase: String
  liquidation_not_ends_with: String
  liquidation_not_ends_with_nocase: String
  liquidation_not_in: [String!]
  liquidation_not_starts_with: String
  liquidation_not_starts_with_nocase: String
  liquidation_starts_with: String
  liquidation_starts_with_nocase: String
  or: [TriggerLiquidation_filter]
  trigger: String
  trigger_: Trigger_filter
  trigger_contains: String
  trigger_contains_nocase: String
  trigger_ends_with: String
  trigger_ends_with_nocase: String
  trigger_gt: String
  trigger_gte: String
  trigger_in: [String!]
  trigger_lt: String
  trigger_lte: String
  trigger_not: String
  trigger_not_contains: String
  trigger_not_contains_nocase: String
  trigger_not_ends_with: String
  trigger_not_ends_with_nocase: String
  trigger_not_in: [String!]
  trigger_not_starts_with: String
  trigger_not_starts_with_nocase: String
  trigger_starts_with: String
  trigger_starts_with_nocase: String
}

input Trigger_filter {
  "Filter for the block changed event."
  _change_block: BlockChangedFilter
  account: Bytes
  account_contains: Bytes
  account_gt: Bytes
  account_gte: Bytes
  account_in: [Bytes!]
  account_lt: Bytes
  account_lte: Bytes
  account_not: Bytes
  account_not_contains: Bytes
  account_not_in: [Bytes!]
  addedBlock: BigInt
  addedBlock_gt: BigInt
  addedBlock_gte: BigInt
  addedBlock_in: [BigInt!]
  addedBlock_lt: BigInt
  addedBlock_lte: BigInt
  addedBlock_not: BigInt
  addedBlock_not_in: [BigInt!]
  addedLogIndex: BigInt
  addedLogIndex_gt: BigInt
  addedLogIndex_gte: BigInt
  addedLogIndex_in: [BigInt!]
  addedLogIndex_lt: BigInt
  addedLogIndex_lte: BigInt
  addedLogIndex_not: BigInt
  addedLogIndex_not_in: [BigInt!]
  addedTimestamp: BigInt
  addedTimestamp_gt: BigInt
  addedTimestamp_gte: BigInt
  addedTimestamp_in: [BigInt!]
  addedTimestamp_lt: BigInt
  addedTimestamp_lte: BigInt
  addedTimestamp_not: BigInt
  addedTimestamp_not_in: [BigInt!]
  addedTransaction: Bytes
  addedTransaction_contains: Bytes
  addedTransaction_gt: Bytes
  addedTransaction_gte: Bytes
  addedTransaction_in: [Bytes!]
  addedTransaction_lt: Bytes
  addedTransaction_lte: Bytes
  addedTransaction_not: Bytes
  addedTransaction_not_contains: Bytes
  addedTransaction_not_in: [Bytes!]
  and: [Trigger_filter]
  cdpId: BigInt
  cdpId_gt: BigInt
  cdpId_gte: BigInt
  cdpId_in: [BigInt!]
  cdpId_lt: BigInt
  cdpId_lte: BigInt
  cdpId_not: BigInt
  cdpId_not_in: [BigInt!]
  cdp_: CDP_filter
  commandAddress: Bytes
  commandAddress_contains: Bytes
  commandAddress_gt: Bytes
  commandAddress_gte: Bytes
  commandAddress_in: [Bytes!]
  commandAddress_lt: Bytes
  commandAddress_lte: Bytes
  commandAddress_not: Bytes
  commandAddress_not_contains: Bytes
  commandAddress_not_in: [Bytes!]
  continuous: Boolean
  continuous_in: [Boolean!]
  continuous_not: Boolean
  continuous_not_in: [Boolean!]
  decodedData: [String!]
  decodedDataNames: [String!]
  decodedDataNames_contains: [String!]
  decodedDataNames_contains_nocase: [String!]
  decodedDataNames_not: [String!]
  decodedDataNames_not_contains: [String!]
  decodedDataNames_not_contains_nocase: [String!]
  decodedData_contains: [String!]
  decodedData_contains_nocase: [String!]
  decodedData_not: [String!]
  decodedData_not_contains: [String!]
  decodedData_not_contains_nocase: [String!]
  executedBlock: BigInt
  executedBlock_gt: BigInt
  executedBlock_gte: BigInt
  executedBlock_in: [BigInt!]
  executedBlock_lt: BigInt
  executedBlock_lte: BigInt
  executedBlock_not: BigInt
  executedBlock_not_in: [BigInt!]
  executedLogIndex: BigInt
  executedLogIndex_gt: BigInt
  executedLogIndex_gte: BigInt
  executedLogIndex_in: [BigInt!]
  executedLogIndex_lt: BigInt
  executedLogIndex_lte: BigInt
  executedLogIndex_not: BigInt
  executedLogIndex_not_in: [BigInt!]
  executedTimestamp: BigInt
  executedTimestamp_gt: BigInt
  executedTimestamp_gte: BigInt
  executedTimestamp_in: [BigInt!]
  executedTimestamp_lt: BigInt
  executedTimestamp_lte: BigInt
  executedTimestamp_not: BigInt
  executedTimestamp_not_in: [BigInt!]
  executedTransaction: Bytes
  executedTransaction_contains: Bytes
  executedTransaction_gt: Bytes
  executedTransaction_gte: Bytes
  executedTransaction_in: [Bytes!]
  executedTransaction_lt: Bytes
  executedTransaction_lte: Bytes
  executedTransaction_not: Bytes
  executedTransaction_not_contains: Bytes
  executedTransaction_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  kind: String
  kind_contains: String
  kind_contains_nocase: String
  kind_ends_with: String
  kind_ends_with_nocase: String
  kind_gt: String
  kind_gte: String
  kind_in: [String!]
  kind_lt: String
  kind_lte: String
  kind_not: String
  kind_not_contains: String
  kind_not_contains_nocase: String
  kind_not_ends_with: String
  kind_not_ends_with_nocase: String
  kind_not_in: [String!]
  kind_not_starts_with: String
  kind_not_starts_with_nocase: String
  kind_starts_with: String
  kind_starts_with_nocase: String
  liquidations_: TriggerLiquidation_filter
  or: [Trigger_filter]
  owner: Bytes
  owner_contains: Bytes
  owner_gt: Bytes
  owner_gte: Bytes
  owner_in: [Bytes!]
  owner_lt: Bytes
  owner_lte: Bytes
  owner_not: Bytes
  owner_not_contains: Bytes
  owner_not_in: [Bytes!]
  protocol: String
  protocol_contains: String
  protocol_contains_nocase: String
  protocol_ends_with: String
  protocol_ends_with_nocase: String
  protocol_gt: String
  protocol_gte: String
  protocol_in: [String!]
  protocol_lt: String
  protocol_lte: String
  protocol_not: String
  protocol_not_contains: String
  protocol_not_contains_nocase: String
  protocol_not_ends_with: String
  protocol_not_ends_with_nocase: String
  protocol_not_in: [String!]
  protocol_not_starts_with: String
  protocol_not_starts_with_nocase: String
  protocol_starts_with: String
  protocol_starts_with_nocase: String
  removedBlock: BigInt
  removedBlock_gt: BigInt
  removedBlock_gte: BigInt
  removedBlock_in: [BigInt!]
  removedBlock_lt: BigInt
  removedBlock_lte: BigInt
  removedBlock_not: BigInt
  removedBlock_not_in: [BigInt!]
  removedLogIndex: BigInt
  removedLogIndex_gt: BigInt
  removedLogIndex_gte: BigInt
  removedLogIndex_in: [BigInt!]
  removedLogIndex_lt: BigInt
  removedLogIndex_lte: BigInt
  removedLogIndex_not: BigInt
  removedLogIndex_not_in: [BigInt!]
  removedTimestamp: BigInt
  removedTimestamp_gt: BigInt
  removedTimestamp_gte: BigInt
  removedTimestamp_in: [BigInt!]
  removedTimestamp_lt: BigInt
  removedTimestamp_lte: BigInt
  removedTimestamp_not: BigInt
  removedTimestamp_not_in: [BigInt!]
  removedTransaction: Bytes
  removedTransaction_contains: Bytes
  removedTransaction_gt: Bytes
  removedTransaction_gte: Bytes
  removedTransaction_in: [Bytes!]
  removedTransaction_lt: Bytes
  removedTransaction_lte: Bytes
  removedTransaction_not: Bytes
  removedTransaction_not_contains: Bytes
  removedTransaction_not_in: [Bytes!]
  tokens: [String!]
  tokens_: Token_filter
  tokens_contains: [String!]
  tokens_contains_nocase: [String!]
  tokens_not: [String!]
  tokens_not_contains: [String!]
  tokens_not_contains_nocase: [String!]
  triggerData: Bytes
  triggerData_contains: Bytes
  triggerData_gt: Bytes
  triggerData_gte: Bytes
  triggerData_in: [Bytes!]
  triggerData_lt: Bytes
  triggerData_lte: Bytes
  triggerData_not: Bytes
  triggerData_not_contains: Bytes
  triggerData_not_in: [Bytes!]
  triggerType: BigInt
  triggerType_gt: BigInt
  triggerType_gte: BigInt
  triggerType_in: [BigInt!]
  triggerType_lt: BigInt
  triggerType_lte: BigInt
  triggerType_not: BigInt
  triggerType_not_in: [BigInt!]
  version: BigInt
  version_gt: BigInt
  version_gte: BigInt
  version_in: [BigInt!]
  version_lt: BigInt
  version_lte: BigInt
  version_not: BigInt
  version_not_in: [BigInt!]
}

input Urn_filter {
  "Filter for the block changed event."
  _change_block: BlockChangedFilter
  and: [Urn_filter]
  cdp: String
  cdp_: CDP_filter
  cdp_contains: String
  cdp_contains_nocase: String
  cdp_ends_with: String
  cdp_ends_with_nocase: String
  cdp_gt: String
  cdp_gte: String
  cdp_in: [String!]
  cdp_lt: String
  cdp_lte: String
  cdp_not: String
  cdp_not_contains: String
  cdp_not_contains_nocase: String
  cdp_not_ends_with: String
  cdp_not_ends_with_nocase: String
  cdp_not_in: [String!]
  cdp_not_starts_with: String
  cdp_not_starts_with_nocase: String
  cdp_starts_with: String
  cdp_starts_with_nocase: String
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [Urn_filter]
}
